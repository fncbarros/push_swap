push_swap Log

pa = push(b, a) pb = push(a, b)
push -> if no src abort <------------------------------
rotate -> if no src abort <------------------------------



/*DEREFERENCE elements using *(int *)a.head->content */
*(int *)ft_lstlast(a->head)->content WORKS!!

Doubly Linked Lists w/ int n -> need remake lstlast lstnew lstadd_front lstclear lstdelone

--------------------------------------------------------------------------------
SEE 2nd_impl/ for implementation w/ doubly-linked-list and double-stack-struct (w/ int as value)
set doubly linked lists on libft.h and push_swap.h without thinking...still
using libft functions as well........................
	lstiter might actually be useful

--------------------------------------------------------------------------------------------

ARG=`ruby -e "puts (0..99).to_a.shuffle.join(' ')"`
----------------->(need create an sh tester script)<-----------------------

ARRAY IMPLEMENTATION OF STACKS:
typedef struct	s_stack
{
	int	stack[CAPACITY];
	int	top;
}		t_stack;

LINKED LIST IMPLEMENTATION OF STACK:
typedef struct	s_stack
{
	t_list	*head;
	ssize_t	size;
}		t_stack;

GETTING ARGUMENTS INTO A LINKED LIST USING LIBFT(original):
int	main(int argc, char **argv)
{
	int		n;
	t_list	*a;
	t_list	*new;
	int		i;

	a = ft_lstnew(argv[1]);
	i = 1;
	while (++i < argc)
		ft_lstadd_back(&a, ft_lstnew(argv[i]));
	new = a;
	while (new->next)							//prints list contents
	{
		n = ft_atoi((char *)new->content);		//casts to str and converts to int
		ft_putnbr_fd(n, 1);
		ft_putchar_fd('\n', 1);
		new = new->next;
	}
	n = ft_atoi((char *)new->content);
	ft_putnbr_fd(n, 1);
	ft_putchar_fd('\n', 1);
	ft_putnbr_fd(ft_lstsize(a), 1);
//	ft_lstclear(&a, (free)(void *)); <----------- Not sure yet how to do this
	return (0);
}

	^ Maybe not the best idea (?)^

POP:
t_list  pop(t_stack *s)
/*
 * Deletes 1st node on stack pointed to by s->head
 * Returns same node*/
{
        t_list  *node;

        node = &(s->head);      /*node points to 1st element of stack*/
        node->next = NULL;      /*isolates element*/
        s->head = s->head->next;        /*stack head points to next element*/
        s->size--;      /*size "decrement"*/
        return (*node); /*return element pointed to by "node"*/
}

PUSH:
void    push(t_list *node, t_stack *s)
/*
 *Add node to list pointed by stack's head
 increment stack size
 does not pop from previous t_list, ...*/
{
        ft_lstadd_back(&(s->head), ft_lstnew(node));
        s->size++;
}
